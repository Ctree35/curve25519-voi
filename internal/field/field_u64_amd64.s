// Copyright (c) 2017 George Tankersley. All rights reserved.
// Copyright (c) 2021 Oasis Labs Inc.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64,!purego,!forcenoasm,!force32bit

#include "textflag.h"

// These routines are based on the ristretto255 package by
// George Tankersley.  The changes made are as follows:
//
//  * Abstract out the reduction and carry into a macro.
//  * Instead of feSquare, implement fePow2k.

// reduce64 reduces the intermediaries stored in rsi, rdi, r8 .. r15.
//
// Inputs:   rsi, rdi, r8 .. r15
// Clobbers: rax, rdx
// Outputs:  rsi, r8, r10, r12, r14
#define reduce64() \
	MOVQ   $2251799813685247, AX \ // (1<<51) - 1
	SHLQ   $13, SI, DI           \ // r01 = shld with r00
	ANDQ   AX, SI                \ // r00 &= mask51
	SHLQ   $13, R8, R9           \ // r11 = shld with r10
	ANDQ   AX, R8                \ // r10 &= mask51
	ADDQ   DI, R8                \ // r10 += r01
	SHLQ   $13, R10, R11         \ // r21 = shld with r20
	ANDQ   AX, R10               \ // r20 &= mask51
	ADDQ   R9, R10               \ // r20 += r11
	SHLQ   $13, R12, R13         \ // r31 = shld with r30
	ANDQ   AX, R12               \ // r30 &= mask51
	ADDQ   R11, R12              \ // r30 += r21
	SHLQ   $13, R14, R15         \ // r41 = shld with r40
	ANDQ   AX, R14               \ // r40 &= mask51
	ADDQ   R13, R14              \ // r40 += r31
	IMUL3Q $19, R15, R15         \ // r41 = r41*19
	ADDQ   R15, SI               \ // r00 += r41
	                             \
	MOVQ   SI, DX                \ // rdx <-- r00
	SHRQ   $51, DX               \ // rdx <-- r00 >> 51
	ADDQ   DX, R8                \ // r10 += r00 >> 51
	MOVQ   R8, DX                \ // rdx <-- r10
	SHRQ   $51, DX               \ // rdx <-- r10 >> 51
	ANDQ   AX, SI                \ // r00 &= mask51
	ADDQ   DX, R10               \ // r20 += r10 >> 51
	MOVQ   R10, DX               \ // rdx <-- r20
	SHRQ   $51, DX               \ // rdx <-- r20 >> 51
	ANDQ   AX, R8                \ // r10 &= mask51
	ADDQ   DX, R12               \ // r30 += r20 >> 51
	MOVQ   R12, DX               \ // rdx <-- r30
	SHRQ   $51, DX               \ // rdx <-- r30 >> 51
	ANDQ   AX, R10               \ // r20 &= mask51
	ADDQ   DX, R14               \ // r40 += r30 >> 51
	MOVQ   R14, DX               \ // rdx <-- r40
	SHRQ   $51, DX               \ // rdx <-- r40 >> 51
	ANDQ   AX, R12               \ // r30 &= mask51
	IMUL3Q $19, DX, DX           \ // rdx <-- (r40 >> 51) * 19
	ADDQ   DX, SI                \ // r00 += (r40 >> 51) *19
	ANDQ   AX, R14               \ // r40 &= mask51

// func feMul(out, a, b *FieldElement)
TEXT ·feMul(SB), NOSPLIT|NOFRAME, $0-24
	MOVQ a+8(FP), BX
	MOVQ b+16(FP), CX

	// Based on assembly generated by PeachPy. Equivalent to the Go in
	// feMulGeneric, which was originally based on the amd64-51-30k
	// assembly in SUPERCOP.

	// Calculate r0
	MOVQ 0(BX), AX // rax <-- x0
	MULQ 0(CX)     // rdx, rax <-- x0*y0
	MOVQ AX, SI    // r00 = rax
	MOVQ DX, DI    // r01 = rdx

	MOVQ   8(BX), DX   // rdx <-- x1
	IMUL3Q $19, DX, AX // rax <-- x1*19
	MULQ   32(CX)      // rdx, rax <-- x1_19*y4
	ADDQ   AX, SI      // r00 += rax
	ADCQ   DX, DI      // r01 += rdx

	MOVQ   16(BX), DX  // rdx <-- x2
	IMUL3Q $19, DX, AX // rax <-- x2*19
	MULQ   24(CX)      // rdx, rax <-- x2_19*y3
	ADDQ   AX, SI      // r00 += rax
	ADCQ   DX, DI      // r01 += rdx

	MOVQ   24(BX), DX  // rdx <-- x3
	IMUL3Q $19, DX, AX // rax <-- x3*19
	MULQ   16(CX)      // rdx, rax <-- x3_19 * y2
	ADDQ   AX, SI      // r00 += rax
	ADCQ   DX, DI      // r01 += rdx

	MOVQ   32(BX), DX  // rdx <-- x4
	IMUL3Q $19, DX, AX // rax <-- x4*19
	MULQ   8(CX)       // rdx rax <-- x4_19*y1
	ADDQ   AX, SI      // r00 += rax
	ADCQ   DX, DI      // r01 += rdx

	// Calculate r1
	MOVQ 0(BX), AX
	MULQ 8(CX)
	MOVQ AX, R8    // r10
	MOVQ DX, R9    // r11

	MOVQ 8(BX), AX
	MULQ 0(CX)
	ADDQ AX, R8
	ADCQ DX, R9

	MOVQ   16(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   32(CX)
	ADDQ   AX, R8
	ADCQ   DX, R9

	MOVQ   24(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   24(CX)
	ADDQ   AX, R8
	ADCQ   DX, R9

	MOVQ   32(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   16(CX)
	ADDQ   AX, R8
	ADCQ   DX, R9

	// Calculate r2
	MOVQ 0(BX), AX
	MULQ 16(CX)
	MOVQ AX, R10   // r20
	MOVQ DX, R11   // r21

	MOVQ 8(BX), AX
	MULQ 8(CX)
	ADDQ AX, R10
	ADCQ DX, R11

	MOVQ 16(BX), AX
	MULQ 0(CX)
	ADDQ AX, R10
	ADCQ DX, R11

	MOVQ   24(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   32(CX)
	ADDQ   AX, R10
	ADCQ   DX, R11

	MOVQ   32(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   24(CX)
	ADDQ   AX, R10
	ADCQ   DX, R11

	// Calculate r3
	MOVQ 0(BX), AX
	MULQ 24(CX)
	MOVQ AX, R12   // r30
	MOVQ DX, R13   // r31

	MOVQ 8(BX), AX
	MULQ 16(CX)
	ADDQ AX, R12
	ADCQ DX, R13

	MOVQ 16(BX), AX
	MULQ 8(CX)
	ADDQ AX, R12
	ADCQ DX, R13

	MOVQ 24(BX), AX
	MULQ 0(CX)
	ADDQ AX, R12
	ADCQ DX, R13

	MOVQ   32(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   32(CX)
	ADDQ   AX, R12
	ADCQ   DX, R13

	// Calculate r4
	MOVQ 0(BX), AX
	MULQ 32(CX)
	MOVQ AX, R14   // r40
	MOVQ DX, R15   // r41

	MOVQ 8(BX), AX
	MULQ 24(CX)
	ADDQ AX, R14
	ADCQ DX, R15

	MOVQ 16(BX), AX
	MULQ 16(CX)
	ADDQ AX, R14
	ADCQ DX, R15

	MOVQ 24(BX), AX
	MULQ 8(CX)
	ADDQ AX, R14
	ADCQ DX, R15

	MOVQ 32(BX), AX
	MULQ 0(CX)
	ADDQ AX, R14
	ADCQ DX, R15

	reduce64()

	MOVQ out+0(FP), DI
	MOVQ SI, 0(DI)
	MOVQ R8, 8(DI)
	MOVQ R10, 16(DI)
	MOVQ R12, 24(DI)
	MOVQ R14, 32(DI)
	RET

// func fePow2k(out, a *FieldElement, k uint64)
//
// Note: This is changed from squaring to support any power-of-two greater
// than zero.
TEXT ·fePow2k(SB), NOSPLIT|NOFRAME, $0-24
	MOVQ a+8(FP), BX
	MOVQ k+16(FP), CX

pow2k_loop:

	// r0 = x0*x0 + x1*38*x4 + x2*38*x3
	MOVQ 0(BX), AX
	MULQ 0(BX)
	MOVQ AX, SI    // r00
	MOVQ DX, DI    // r01

	MOVQ   8(BX), DX
	IMUL3Q $38, DX, AX
	MULQ   32(BX)
	ADDQ   AX, SI
	ADCQ   DX, DI

	MOVQ   16(BX), DX
	IMUL3Q $38, DX, AX
	MULQ   24(BX)
	ADDQ   AX, SI
	ADCQ   DX, DI

	// r1 = x0*2*x1 + x2*38*x4 + x3*19*x3
	MOVQ 0(BX), AX
	SHLQ $1, AX
	MULQ 8(BX)
	MOVQ AX, R8    // r10
	MOVQ DX, R9    // r11

	MOVQ   16(BX), DX
	IMUL3Q $38, DX, AX
	MULQ   32(BX)
	ADDQ   AX, R8
	ADCQ   DX, R9

	MOVQ   24(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   24(BX)
	ADDQ   AX, R8
	ADCQ   DX, R9

	// r2 = x0*2*x2 + x1*x1 + x3*38*x4
	MOVQ 0(BX), AX
	SHLQ $1, AX
	MULQ 16(BX)
	MOVQ AX, R10   // r20
	MOVQ DX, R11   // r21

	MOVQ 8(BX), AX
	MULQ 8(BX)
	ADDQ AX, R10
	ADCQ DX, R11

	MOVQ   24(BX), DX
	IMUL3Q $38, DX, AX
	MULQ   32(BX)
	ADDQ   AX, R10
	ADCQ   DX, R11

	// r3 = x0*2*x3 + x1*2*x2 + x4*19*x4
	MOVQ 0(BX), AX
	SHLQ $1, AX
	MULQ 24(BX)
	MOVQ AX, R12   // r30
	MOVQ DX, R13   // r31

	MOVQ 8(BX), AX
	SHLQ $1, AX
	MULQ 16(BX)
	ADDQ AX, R12
	ADCQ DX, R13

	MOVQ   32(BX), DX
	IMUL3Q $19, DX, AX
	MULQ   32(BX)
	ADDQ   AX, R12
	ADCQ   DX, R13

	// r4 = x0*2*x4 + x1*2*x3 + x2*x2
	MOVQ 0(BX), AX
	SHLQ $1, AX
	MULQ 32(BX)
	MOVQ AX, R14   // r40
	MOVQ DX, R15   // r41

	MOVQ 8(BX), AX
	SHLQ $1, AX
	MULQ 24(BX)
	ADDQ AX, R14
	ADCQ DX, R15

	MOVQ 16(BX), AX
	MULQ 16(BX)
	ADDQ AX, R14
	ADCQ DX, R15

	// Reduce
	reduce64()

	MOVQ out+0(FP), BX
	MOVQ SI, 0(BX)
	MOVQ R8, 8(BX)
	MOVQ R10, 16(BX)
	MOVQ R12, 24(BX)
	MOVQ R14, 32(BX)

	DECQ CX
	JNZ  pow2k_loop
	RET
